<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RUKA-PORRO - Voxel Game in Lapland Taiga</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
        }
        #info h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #87CEEB;
        }
        #info p {
            margin: 5px 0;
            line-height: 1.4;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 20px;
            text-align: center;
        }
        .key {
            background: #444;
            padding: 2px 8px;
            border-radius: 4px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="loading">Loading Lapland Taiga...</div>
    <div id="info" style="display: none;">
        <h1>RUKA-PORRO</h1>
        <p>Voxel Game in Lapland Taiga</p>
        <hr style="margin: 10px 0; border-color: #555;">
        <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> - Move</p>
        <p><span class="key">SPACE</span> - Jump</p>
        <p><span class="key">Mouse</span> - Look around</p>
        <p><span class="key">Click</span> - Start/Lock pointer</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer;
        let player = { x: 0, y: 5, z: 0, vx: 0, vy: 0, vz: 0, onGround: false };
        let keys = {};
        let mouseX = 0, mouseY = 0;
        let rotationX = 0, rotationY = 0;
        let blocks = [];
        let poros = [];
        let snowflakes = [];
        let trees = [];

        // Colors
        const COLORS = {
            snow: 0xFAFAFA,
            ice: 0xADD8E6,
            wood: 0x8B4513,
            leaves: 0x228B22,
            darkLeaves: 0x006400,
            poro: 0xD2B48C,
            poroAntlers: 0x8B7355,
            sky: 0x87CEEB,
            fog: 0xC0D6E4
        };

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.sky);
            scene.fog = new THREE.Fog(COLORS.fog, 20, 80);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // Generate world
            generateTerrain();
            generateTrees();
            generatePoros();
            generateSnowflakes();

            // Event listeners
            document.addEventListener('keydown', (e) => keys[e.code] = true);
            document.addEventListener('keyup', (e) => keys[e.code] = false);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                    document.getElementById('info').style.display = 'block';
                }
            });

            window.addEventListener('resize', onWindowResize);

            // Hide loading
            document.getElementById('loading').style.display = 'none';
            document.getElementById('info').style.display = 'block';

            // Start game loop
            animate();
        }

        function createVoxel(x, y, z, color, size = 1) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
            return cube;
        }

        function generateTerrain() {
            const size = 50;
            for (let x = -size; x < size; x++) {
                for (let z = -size; z < size; z++) {
                    // Base snow layer
                    const height = Math.floor(Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2);
                    const block = createVoxel(x, height, z, COLORS.snow);
                    blocks.push({ mesh: block, x, y: height, z });

                    // Random ice patches
                    if (Math.random() < 0.05) {
                        const iceBlock = createVoxel(x, height + 0.01, z, COLORS.ice);
                        blocks.push({ mesh: iceBlock, x, y: height + 0.01, z });
                    }
                }
            }
        }

        function generateTrees() {
            for (let i = 0; i < 100; i++) {
                const x = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 80;
                const height = Math.floor(Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2);

                // Don't place trees too close to spawn
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;

                createTree(x, height + 1, z);
            }
        }

        function createTree(x, y, z) {
            const trunkHeight = 3 + Math.floor(Math.random() * 3);

            // Trunk
            for (let i = 0; i < trunkHeight; i++) {
                const trunk = createVoxel(x, y + i, z, COLORS.wood);
                trees.push(trunk);
            }

            // Conical leaves (pine tree style)
            const leafLayers = 4;
            for (let layer = 0; layer < leafLayers; layer++) {
                const layerY = y + trunkHeight + layer;
                const radius = leafLayers - layer;

                for (let lx = -radius; lx <= radius; lx++) {
                    for (let lz = -radius; lz <= radius; lz++) {
                        if (Math.abs(lx) + Math.abs(lz) <= radius) {
                            const leafColor = Math.random() > 0.3 ? COLORS.leaves : COLORS.darkLeaves;
                            const leaf = createVoxel(x + lx, layerY, z + lz, leafColor);

                            // Snow on top of leaves
                            if (layer === leafLayers - 1 || (Math.random() > 0.5 && layer === leafLayers - 2)) {
                                const snow = createVoxel(x + lx, layerY + 0.5, z + lz, COLORS.snow, 0.8);
                            }
                            trees.push(leaf);
                        }
                    }
                }
            }

            // Top
            const top = createVoxel(x, y + trunkHeight + leafLayers, z, COLORS.darkLeaves);
            const topSnow = createVoxel(x, y + trunkHeight + leafLayers + 0.4, z, COLORS.snow, 0.6);
            trees.push(top);
        }

        function generatePoros() {
            for (let i = 0; i < 8; i++) {
                const x = (Math.random() - 0.5) * 60;
                const z = (Math.random() - 0.5) * 60;
                const height = Math.floor(Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2);

                // Don't place poros too close to spawn
                if (Math.abs(x) < 8 && Math.abs(z) < 8) continue;

                createPoro(x, height + 1, z);
            }
        }

        function createPoro(x, y, z) {
            const poro = new THREE.Group();

            // Body
            const bodyGeom = new THREE.BoxGeometry(1.5, 1, 2);
            const bodyMat = new THREE.MeshLambertMaterial({ color: COLORS.poro });
            const body = new THREE.Mesh(bodyGeom, bodyMat);
            body.position.y = 0.5;
            body.castShadow = true;
            poro.add(body);

            // Head
            const headGeom = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const head = new THREE.Mesh(headGeom, bodyMat);
            head.position.set(0, 1, 1);
            head.castShadow = true;
            poro.add(head);

            // Snout
            const snoutGeom = new THREE.BoxGeometry(0.4, 0.3, 0.4);
            const snoutMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
            const snout = new THREE.Mesh(snoutGeom, snoutMat);
            snout.position.set(0, 0.9, 1.5);
            poro.add(snout);

            // Eyes
            const eyeGeom = new THREE.BoxGeometry(0.15, 0.15, 0.1);
            const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
            leftEye.position.set(-0.25, 1.1, 1.35);
            poro.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
            rightEye.position.set(0.25, 1.1, 1.35);
            poro.add(rightEye);

            // Antlers
            const antlerMat = new THREE.MeshLambertMaterial({ color: COLORS.poroAntlers });

            // Left antler
            const leftAntler1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.8, 0.15), antlerMat);
            leftAntler1.position.set(-0.3, 1.7, 0.9);
            leftAntler1.rotation.z = -0.3;
            poro.add(leftAntler1);

            const leftAntler2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), antlerMat);
            leftAntler2.position.set(-0.5, 2, 0.9);
            poro.add(leftAntler2);

            // Right antler
            const rightAntler1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.8, 0.15), antlerMat);
            rightAntler1.position.set(0.3, 1.7, 0.9);
            rightAntler1.rotation.z = 0.3;
            poro.add(rightAntler1);

            const rightAntler2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), antlerMat);
            rightAntler2.position.set(0.5, 2, 0.9);
            poro.add(rightAntler2);

            // Legs
            const legGeom = new THREE.BoxGeometry(0.25, 0.6, 0.25);
            const legMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 });

            const leg1 = new THREE.Mesh(legGeom, legMat);
            leg1.position.set(-0.4, -0.2, 0.6);
            poro.add(leg1);

            const leg2 = new THREE.Mesh(legGeom, legMat);
            leg2.position.set(0.4, -0.2, 0.6);
            poro.add(leg2);

            const leg3 = new THREE.Mesh(legGeom, legMat);
            leg3.position.set(-0.4, -0.2, -0.6);
            poro.add(leg3);

            const leg4 = new THREE.Mesh(legGeom, legMat);
            leg4.position.set(0.4, -0.2, -0.6);
            poro.add(leg4);

            // Tail
            const tailGeom = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const tail = new THREE.Mesh(tailGeom, bodyMat);
            tail.position.set(0, 0.6, -1.1);
            poro.add(tail);

            poro.position.set(x, y, z);
            poro.rotation.y = Math.random() * Math.PI * 2;

            scene.add(poro);
            poros.push({
                mesh: poro,
                targetRotation: poro.rotation.y,
                moveTimer: Math.random() * 100,
                speed: 0.01 + Math.random() * 0.02
            });
        }

        function generateSnowflakes() {
            for (let i = 0; i < 500; i++) {
                const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
                const snowflake = new THREE.Mesh(geometry, material);

                snowflake.position.set(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 50,
                    (Math.random() - 0.5) * 100
                );

                scene.add(snowflake);
                snowflakes.push({
                    mesh: snowflake,
                    speed: 0.02 + Math.random() * 0.03,
                    wobble: Math.random() * Math.PI * 2
                });
            }
        }

        function onMouseMove(e) {
            if (document.pointerLockElement === renderer.domElement) {
                rotationY -= e.movementX * 0.002;
                rotationX -= e.movementY * 0.002;
                rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function getTerrainHeight(x, z) {
            return Math.floor(Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2) + 1;
        }

        function updatePlayer() {
            const speed = 0.15;
            const jumpForce = 0.2;
            const gravity = 0.01;
            const friction = 0.85;

            // Movement
            let moveX = 0, moveZ = 0;

            if (keys['KeyW']) moveZ -= 1;
            if (keys['KeyS']) moveZ += 1;
            if (keys['KeyA']) moveX -= 1;
            if (keys['KeyD']) moveX += 1;

            // Normalize diagonal movement
            if (moveX !== 0 && moveZ !== 0) {
                moveX *= 0.707;
                moveZ *= 0.707;
            }

            // Apply rotation to movement
            const sinY = Math.sin(rotationY);
            const cosY = Math.cos(rotationY);

            player.vx += (moveX * cosY - moveZ * sinY) * speed;
            player.vz += (moveX * sinY + moveZ * cosY) * speed;

            // Jump
            if (keys['Space'] && player.onGround) {
                player.vy = jumpForce;
                player.onGround = false;
            }

            // Gravity
            player.vy -= gravity;

            // Apply friction
            player.vx *= friction;
            player.vz *= friction;

            // Update position
            player.x += player.vx;
            player.y += player.vy;
            player.z += player.vz;

            // Ground collision
            const groundHeight = getTerrainHeight(player.x, player.z) + 1.5;
            if (player.y < groundHeight) {
                player.y = groundHeight;
                player.vy = 0;
                player.onGround = true;
            }

            // Update camera
            camera.position.set(player.x, player.y, player.z);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = rotationY;
            camera.rotation.x = rotationX;
        }

        function updatePoros() {
            poros.forEach(poro => {
                poro.moveTimer++;

                // Change direction occasionally
                if (poro.moveTimer > 200 + Math.random() * 200) {
                    poro.targetRotation = Math.random() * Math.PI * 2;
                    poro.moveTimer = 0;
                }

                // Smooth rotation
                const rotDiff = poro.targetRotation - poro.mesh.rotation.y;
                poro.mesh.rotation.y += rotDiff * 0.02;

                // Move forward
                const moveSpeed = poro.speed;
                poro.mesh.position.x += Math.sin(poro.mesh.rotation.y) * moveSpeed;
                poro.mesh.position.z += Math.cos(poro.mesh.rotation.y) * moveSpeed;

                // Keep on terrain
                const height = getTerrainHeight(poro.mesh.position.x, poro.mesh.position.z);
                poro.mesh.position.y = height + 0.5;

                // Bounce slightly (walking animation)
                poro.mesh.position.y += Math.sin(poro.moveTimer * 0.2) * 0.05;

                // Keep within bounds
                if (Math.abs(poro.mesh.position.x) > 40 || Math.abs(poro.mesh.position.z) > 40) {
                    poro.targetRotation = Math.atan2(-poro.mesh.position.x, -poro.mesh.position.z);
                }
            });
        }

        function updateSnowflakes() {
            snowflakes.forEach(snow => {
                snow.mesh.position.y -= snow.speed;
                snow.wobble += 0.02;
                snow.mesh.position.x += Math.sin(snow.wobble) * 0.01;

                // Reset snowflake when it hits ground
                if (snow.mesh.position.y < -5) {
                    snow.mesh.position.y = 40 + Math.random() * 10;
                    snow.mesh.position.x = player.x + (Math.random() - 0.5) * 80;
                    snow.mesh.position.z = player.z + (Math.random() - 0.5) * 80;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            updatePlayer();
            updatePoros();
            updateSnowflakes();

            renderer.render(scene, camera);
        }

        // Start game when page loads
        window.onload = init;
    </script>
</body>
</html>
